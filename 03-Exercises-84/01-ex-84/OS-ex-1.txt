#-------------------------------------------------------------------------------------------------------------------------------------------------------#
#### Task 5 #### 

Objective: 
Implement a thread-local storage (TLS) mechanism using a statically allocated array. 
This TLS must reside in the data segment (i.e., no dynamic memory allocation) and you must not use C11 or compiler-specific thread-local keywords (e.g., thread or Thread local).
Important: 
The TLS resides within the global variable g tls which is the array that holds the TLS entries. 
For simplicity we are limiting the size of the array, so you don’t need to do any dynamic allocations.

Details:
• Structure: Define a structure tls data t as follows:

# include <stdint .h>
# include <pthread .h>

# define MAX_THREADS 100

typedef struct {
    int64_t thread_id ; // For an unused entry , initialize to -1
    void * data ; // Initialize to NULL
} tls_data_t ;

• g tls is an array of tls entry t, which holds the thread ID and a void* pointer that points to the data.
• Initialize g tls so that all thread id fields are set to -1 and all data pointers are NULL, so we will know all the entries are not usable by any thread.
• When initializing TLS for a thread:
– Search g tls for the first empty slot and set the thread ID (using pthread self()).
– If the thread ID already exists, simply return.
– If the TLS is full, print:
thread [thread id] failed to initialize, not enough space
exit with return code 1 with exit(1).
– Search should have a runtime complexity of O(n).
• When setting data (i.e. void*) to the TLS, find the entry corresponding to the calling thread and
update its data.
• When retrieving data, find the relevant entry in the TLS and return the data.
• if the thread’s entry is not found durting get or set operations, print:
thread [thread id] hasn’t been initialized in the TLS
exit with return code 2 with exit(2).
• To free a TLS entry, reset the thread id to -1 and data to NULL.
• Important: Ensure that the mapping and TLS updates are mutuality excluded using your own
synchronization mechanisms.
• Important: If the data points to a variable on the stack, the pointer will become dangling if the
variable goes out of scope. For your tests, you may also use malloc to provide a void* to data on the
heap, but notice, once you free the data, the pointer in the TLS dangles. Both pointers to variables on
the stack and on the heap must work. You cannot assume in the TLS anything about the void* data.
Mandatory Definitions and Functions:

void init_storage ();
/*
* Initializes g_tls as an array of MAX_THREADS entries .
*/

void tls_thread_alloc ();
// Initializes the TLS entry for the calling thread .

void * get_tls_data ( void );
/*
* Returns a pointer to the arbitrary data stored for the calling thread .
*/

void set_tls_data ( void * data );
/*
* Sets the given void * data to the TLS for the calling thread .
*/

void tls_thread_free ();
// Frees the TLS entry for the calling thread .
Listing 6: Mandatory Definitions and Functions for Task 5

Submit your implementation in local storage.c and any additional files (if there are any).
#-------------------------------------------------------------------------------------------------------------------------------------------------------#

#-------------------------------------------------------------------------------------------------------------------------------------------------------#

Task 6
Objective: Implement a Producer-Consumer pattern program that checks if numbers are divisible by 6.
Detailed Requirements:
• Producers:
– Generate random numbers in the range from a variable [lowest number generated] (initially 0) up
to 1,000,000.
– Continue generating until all numbers in the range have been produced (ensure the same number
is never passed twice).
– Print to stdout in the following format:
Producer {thread ID} generated number: {number}
– After printing, push the number to a shared queue.
• Consumers:
– Pull numbers from the shared queue.
– Check if the number is divisible by 6.
– Print to stdout in the following format:
Consumer {thread ID} checked {number}. Is it divisible by 6? {result}
where {result} is either True or False (case-sensitive).
– Ensure that printing is synchronized to avoid overlapping output.
• Program Input: The program should accept exactly 3 command-line arguments:
1. Number of Producers.
2. Number of Consumers.
3. Seed for random number generation.
• Configuration Printout: Before starting the producers and consumers, print:
Number of Consumers: {Number of Consumers}
Number of Producers: {Number of Producers}
Seed: {Seed}
• Error Handling: If the argument count or values are incorrect, print the usage message:
usage: cp pattern [consumers] [producers] [seed]
and exit with return code 1.
• Use srand() with the provided seed and generate numbers using rand() % x.
• Once all numbers have been generated, a producer should signal a global condition variable.
• Provide a function to check if the consumer queue is empty.
• In the main function (which you must submit for this task), use the condition variable to wait until
the producers have finished, then busy-wait until the consumers complete processing.
• After the consumers finish processing, shutdown all consumer and producer threads and exit with code
0.
6
• Note: Dynamic memory allocation is allowed in this task; however, ensure that all allocated
memory is properly freed.
• After all the numbers were generated and pushed to the queue, the producers threads finish and return
from their thread function.
• Main Thread - General Flow
1. Starts the producers
2. Starts the consumers
3. Waits until the producers have produced all the numbers – wait until producers produced all numbers()
4. Waits until the consumers have consumed all the jobs the producers produced – wait consumers queue empty()
5. Stops the consumers “thread pool” cleanly – stop consumers()
• Note: In class, we discussed the general producer/consumer pattern using two condition variables
(is full and is work). In this exercise, you only need to use a single condition variable (e.g., is empty)
to signal when there is work in the queue. You can assume the queue is large enough that it will never
become full, so you do not need to handle the is full case.
Mandatory Functions:
1 void start_consumers_producers ( int consumers , int producers , int seed );
2 /*
3 * Starts the consumers and producers , and passes the seed to the producers .
4 */
5
6 void stop_consumers ();
7 /*
8 * Stops the consumer threads .
9 */
10
11 void print_msg ( const char * msg);
12 // Prints a message synchronously to avoid overlapping output .
13
14 void wait_until_producers_produced_all_numbers ();
15 /*
16 * Waits until all numbers between 0 and 1 ,000 ,000 have been produced .
17 */
18
19 void wait_consumers_queue_empty ();
20 /*
21 * wait until queue is empty , if queue is already empty
22 * return immediately without waiting .
23 */
Listing 7: Mandatory functions for Task 6
Submit your implementation in cp pattern.c and any additional files (if there are any).
Final Notes
• Read the Instructions Carefully: Ensure that you adhere to all restrictions and requirements.
• Testing: Test your code thoroughly with various inputs to ensure correctness, especially under concurrent
execution.
– Also test without a debugger since debuggers may affect synchronization behavior and hide bugs.
– Debugging: Start with a small number of threads (e.g., one, then two, then five) and increase gradually.
– Use debug printouts to help identify issues, but make sure to remove or comment out any debug messages before submission as they may affect grading.
• Code Quality: Write clean, well-commented code to help the graders understand your implementation. Comments will also help you understand what you are trying to achieve.
• Unit Tests: You are (more than) encouraged to use unit tests to validate your synchronization mechanisms.